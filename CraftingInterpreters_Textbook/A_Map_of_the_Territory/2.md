#### The Parts of a Language
- The way we build programming languages has been virtually unchanged since the dark ages of programming.
- ![Alt text](image.png)
#### Scanning
- Scanning takes in a bunch of characters and chunks them into something more like words.
  - Why would it go from characters to words. This analogy is not obvious to me aren't we supposed to be breaking things apart into lower levels?
#### Parsing
- This actually has its roots in the AI community where they were trying to get computers to talk to us. Turns out the strict grammer rules were too strict to be used with human language but perfect for programming languages.
- Parsing is where the Abstract Syntax Tree gets build
  - Its where the grammer of the language is build and its also where syntax errors are reported.
#### Static Analysis
- The first two stages are pretty similar in language implementations. Now the individual characteristics of languages start to come into play.
- this is where type checking and the region of where a variable is declared is identified so scoping also becomes a thing here.
- This is where the language gets its semantic meaning. We can use a symbol table here as well.
- Everything up to here is the **front end** of the implementation. There used to be just a **back end** following this but that was back when compilers were simpler. Now there is a **middle end** before the **back end**.
#### Intermediate Representations
- This is useful for when you want a source language to run on multiple CPUs. You can have a intermediate representation so you do not have to write a compiler for each architecture.
#### Optimization
- This is a rathole for people obsessed with optimizing code to get the compilers a little faster. Many successful languages have surprisingly few compile-time optimziations they focus most of their performance efforts on runtime (CPython, Lua).
- Once we understand what the user's program means we can swap it out for a more efficient implementation.
#### Code Generation
- It is hard to generate code to run on the CPU directly. There is a lot of historical baggage surrounding the design of CPUs.
- Virtual machine code is a better way to do this. Instead of producing code for a chip they do it for a hypothesized, ideal virtual machine
  - Okay then what?
  - And this is called bytecode
#### Virtual Machine